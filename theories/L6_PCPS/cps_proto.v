(* Expressions and contexts isomorphic to those defined in cps.v and ctx.v.
   We define a separate copy of these because:
   - The MetaCoq in Prototype.v doesn't support treating AST types defined with type aliases
     like [var] and [fun_tag] differently.
   - Even if it were OK to treat them the same, rewriting the definition of [exp] to use
     the raw [positive] type and then defining the aliases afterwards breaks proofs about
     [exp]s that make use of autogenerated names, because Coq uses constructor argument
     types for name generation.
   - Prototype.v additionally generates a type of one-hole contexts for [exp] trees and
     we have to explain how this type relates to [exp_ctx] and [fundefs_ctx].

   The actual definition of [exp] is in cps_proto_metacoq.v because the MetaCoq takes a
   lot of time and space (~6 GB) to run (most of this is for quoting exp_aux_data). *)

From Coq Require Import ZArith.ZArith Lists.List.
Import ListNotations.

Require Import CertiCoq.L6.Prototype.

Require Export CertiCoq.L6.cps_proto_metacoq.
Print exp_univ.
Print exp_univD.
Print exp_frame_t.
Print exp_frameD.
Print exp_Frame_ops.

Require CertiCoq.L6.cps.
Require Import CertiCoq.L6.ctx.

(* The type of one-hole contexts *)
Definition exp_c : exp_univ -> exp_univ -> Set := frames_t.

(* -------------------- exp is isomorphic to cps.exp -------------------- *)

Definition strip_vars : list var -> list cps.var := map (fun '(mk_var x) => x).

Fixpoint exp_of_proto (e : exp) : cps.exp :=
  match e with
  | Econstr (mk_var x) (mk_ctor_tag c) ys e => cps.Econstr x c (strip_vars ys) (exp_of_proto e)
  | Ecase (mk_var x) ces => cps.Ecase x (map (fun '(mk_ctor_tag c, e) => (c, exp_of_proto e)) ces)
  | Eproj (mk_var x) (mk_ctor_tag c) n (mk_var y) e => cps.Eproj x c n y (exp_of_proto e)
  | Eletapp (mk_var x) (mk_var f) (mk_fun_tag ft) ys e =>
    cps.Eletapp x f ft (strip_vars ys) (exp_of_proto e)
  | Efun fds e => cps.Efun (fundefs_of_proto fds) (exp_of_proto e)
  | Eapp (mk_var f) (mk_fun_tag ft) xs => cps.Eapp f ft (strip_vars xs)
  | Eprim (mk_var x) (mk_prim p) ys e => cps.Eprim x p (strip_vars ys) (exp_of_proto e)
  | Ehalt (mk_var x) => cps.Ehalt x
  end
with fundefs_of_proto (fds : fundefs) : cps.fundefs :=
  match fds with
  | Fcons (mk_var f) (mk_fun_tag ft) xs e fds =>
    cps.Fcons f ft (strip_vars xs) (exp_of_proto e) (fundefs_of_proto fds)
  | Fnil => cps.Fnil
  end.
Definition ce_of_proto := fun '(mk_ctor_tag c, e) => (c, exp_of_proto e).
Definition ces_of_proto := map ce_of_proto.

Fixpoint proto_of_exp (e : cps.exp) : exp :=
  match e with
  | cps.Econstr x c ys e => Econstr (mk_var x) (mk_ctor_tag c) (map mk_var ys) (proto_of_exp e)
  | cps.Ecase x ces => Ecase (mk_var x) (map (fun '(c, e) => (mk_ctor_tag c, proto_of_exp e)) ces)
  | cps.Eproj x c n y e => Eproj (mk_var x) (mk_ctor_tag c) n (mk_var y) (proto_of_exp e)
  | cps.Eletapp x f ft ys e =>
    Eletapp (mk_var x) (mk_var f) (mk_fun_tag ft) (map mk_var ys) (proto_of_exp e)
  | cps.Efun fds e => Efun (proto_of_fundefs fds) (proto_of_exp e)
  | cps.Eapp f ft ys => Eapp (mk_var f) (mk_fun_tag ft) (map mk_var ys)
  | cps.Eprim x p ys e => Eprim (mk_var x) (mk_prim p) (map mk_var ys) (proto_of_exp e)
  | cps.Ehalt x => Ehalt (mk_var x)
  end
with proto_of_fundefs (fds : cps.fundefs) : fundefs :=
  match fds with
  | cps.Fcons f ft xs e fds =>
    Fcons (mk_var f) (mk_fun_tag ft) (map mk_var xs) (proto_of_exp e) (proto_of_fundefs fds)
  | cps.Fnil => Fnil
  end.
Definition proto_of_ce := fun '(c, e) => (mk_ctor_tag c, proto_of_exp e).
Definition proto_of_ces := map proto_of_ce.

Lemma strip_vars_map xs : strip_vars (map mk_var xs) = xs.
Proof. induction xs as [|x xs IHxs]; simpl; congruence. Qed.

Fixpoint exp_proto_exp e : exp_of_proto (proto_of_exp e) = e
with fundefs_proto_fundefs fds : fundefs_of_proto (proto_of_fundefs fds) = fds.
Proof.
  - destruct e; simpl; try rewrite strip_vars_map; try congruence.
    induction l as [ | [c e] ces IHces]; [reflexivity|]; simpl.
    inversion IHces.
    repeat rewrite H0.
    repeat f_equal.
    now apply exp_proto_exp.
  - destruct fds; simpl; try rewrite strip_vars_map; congruence.
Qed.

Lemma map_strip_vars xs : map mk_var (strip_vars xs) = xs.
Proof. induction xs as [| [x] xs IHxs]; simpl; congruence. Qed.

Local Ltac destruct_sings :=
  repeat match goal with |- context [match ?x with _ => _ end] => destruct x as [x]; simpl end.

Fixpoint proto_exp_proto e : proto_of_exp (exp_of_proto e) = e
with proto_fundefs_proto fds : proto_of_fundefs (fundefs_of_proto fds) = fds.
Proof.
  - destruct e; simpl; destruct_sings; try rewrite map_strip_vars; try congruence.
    induction ces as [| [[c] e] ces IHces]; [reflexivity|]; simpl.
    inversion IHces.
    repeat rewrite H0.
    repeat f_equal.
    now apply proto_exp_proto.
  - destruct fds; simpl; destruct_sings; try rewrite map_strip_vars; congruence.
Qed.

(* ---------- exp_c with the right indices is isomorphic to cps.exp_ctx and cps.fundefs_ctx ---------- *)

Fixpoint c_of_exp_ctx (C : exp_ctx) : exp_c exp_univ_exp exp_univ_exp
with c_of_fundefs_ctx (C : fundefs_ctx) : exp_c exp_univ_exp exp_univ_fundefs.
Proof.
  - refine (
      match C with
      | Hole_c => <[]>
      | Econstr_c x c ys C => <[Econstr3 (mk_var x) (mk_ctor_tag c) (map mk_var ys)]> >++ c_of_exp_ctx C
      | Eproj_c x c n y C => <[Eproj4 (mk_var x) (mk_ctor_tag c) n (mk_var y)]> >++ c_of_exp_ctx C
      | Eprim_c x p ys C => <[Eprim3 (mk_var x) (mk_prim p) (map mk_var ys)]> >++ c_of_exp_ctx C
      | Eletapp_c x f ft ys C =>
        <[Eletapp4 (mk_var x) (mk_var f) (mk_fun_tag ft) (map mk_var ys)]> >++ c_of_exp_ctx C
      | Ecase_c x ces1 c C ces2 =>
        let prefix := 
          fold_right
            (fun '(c, e) frames =>
              frames >:: cons_prod_ctor_tag_exp1 (mk_ctor_tag c, proto_of_exp e))
            <[Ecase1 (mk_var x)]>
            ces1
        in
        prefix
          >++ <[cons_prod_ctor_tag_exp0 (proto_of_ces ces2); pair_ctor_tag_exp1 (mk_ctor_tag c)]>
          >++ c_of_exp_ctx C
      | Efun1_c fds C => <[Efun1 (proto_of_fundefs fds)]> >++ c_of_exp_ctx C
      | Efun2_c C e => <[Efun0 (proto_of_exp e)]> >++ c_of_fundefs_ctx C
      end).
  - refine (
      match C with
      | Fcons1_c f ft xs C fds =>
        <[Fcons3 (mk_var f) (mk_fun_tag ft) (map mk_var xs) (proto_of_fundefs fds)]> >++ c_of_exp_ctx C
      | Fcons2_c f ft xs e C =>
        <[Fcons4 (mk_var f) (mk_fun_tag ft) (map mk_var xs) (proto_of_exp e)]> >++ c_of_fundefs_ctx C
      end).
Defined.

Inductive zero : Set :=.
Definition univ_rep (A : exp_univ) : Set :=
  match A with
  | exp_univ_prod_ctor_tag_exp => cps.ctor_tag * exp_ctx
  | exp_univ_list_prod_ctor_tag_exp =>
    list (cps.ctor_tag * cps.exp) * cps.ctor_tag * exp_ctx * list (cps.ctor_tag * cps.exp)
  | exp_univ_fundefs => fundefs_ctx
  | exp_univ_exp => exp_ctx
  | exp_univ_var => zero
  | exp_univ_fun_tag => zero
  | exp_univ_ctor_tag => zero
  | exp_univ_prim => zero
  | exp_univ_N => zero
  | exp_univ_list_var => zero
  end.

Local Ltac unbox_newtypes :=
  repeat lazymatch goal with
  | x : var |- _ => destruct x as [x]
  | x : prim |- _ => destruct x as [x]
  | x : fun_tag |- _ => destruct x as [x]
  | x : ctor_tag |- _ => destruct x as [x]
  end.

Definition exp_frame_rep {A B} (f : exp_frame_t A B) : univ_rep A -> univ_rep B.
Proof.
  destruct f eqn:Hf; simpl; unbox_newtypes;
   try lazymatch goal with |- zero -> _ => inversion 1 end.
  - exact (fun ctx => (c, ctx)).
  - exact (fun '(c, e) => ([], c, e, ces_of_proto l)).
  - exact (fun '(ces1, c, e, ces2) => (ce_of_proto p :: ces1, c, e, ces2)).
  - exact (fun ctx => Fcons1_c v f0 (strip_vars l) ctx (fundefs_of_proto f1)).
  - exact (fun ctx => Fcons2_c v f0 (strip_vars l) (exp_of_proto e) ctx).
  - exact (fun ctx => Econstr_c v c (strip_vars l) ctx).
  - exact (fun '(ces1, c, e, ces2) => Ecase_c v ces1 c e ces2).
  - exact (fun ctx => Eproj_c v c n v0 ctx).
  - exact (fun ctx => Eletapp_c v v0 f0 (strip_vars l) ctx).
  - exact (fun ctx => Efun2_c ctx (exp_of_proto e)).
  - exact (fun ctx => Efun1_c (fundefs_of_proto f0) ctx).
  - exact (fun ctx => Eprim_c v p (strip_vars l) ctx).
Defined.

Fixpoint exp_c_rep {A B} (C : exp_c A B) : univ_rep A -> univ_rep B :=
  match C with
  | <[]> => fun x => x
  | C >:: f => fun x => exp_c_rep C (exp_frame_rep f x)
  end.

Definition exp_ctx_of_c (C : exp_c exp_univ_exp exp_univ_exp) : exp_ctx :=
  exp_c_rep C Hole_c.

Definition fundefs_ctx_of_c (C : exp_c exp_univ_exp exp_univ_fundefs) : fundefs_ctx :=
  exp_c_rep C Hole_c.
